import os
import io
import zipfile

from flask import Flask, request, jsonify
from functools import wraps
import yaml

import docker
import subprocess
import threading
import time


def return_0_1(code: int =200 , message: str = "done", data: dict = {"v":"k"}):
    #  this code for returning response of POST(GET) with json format
    response = {
        "code": code,
        "message": message,
        "data": data
    }

    return jsonify(response)


def share_weight(contain_id, shared_path):
    #  this function for sharing weights of one model generated by different adversarial methods.
    return 0


def update_dict_1_level(original, new):
    # just update dict key
    for key, value in new.items():
        if key not in original:
            original[key] = value


def update_dict_2_level(original, new):
    # if new dict's model is same with origin, update the 2 level key 'weight_number', 'weight_name',
    # 'test_method', and 'download_addr'
    for key, value in new.items():
        if key not in original:
            original[key] = value
        else:
            if isinstance(original[key]['weight_number'], int):
                original[key]['weight_number'] = original[key]['weight_number'] + new[key]['weight_number']
            else:
                original[key]['weight_number'] = int(original[key]['weight_number']) + int(new[key]['weight_number'])

            for kkey in ['weight_name', 'test_method', 'download_addr']:
                if isinstance(original[key][kkey], str) and isinstance(new[key][kkey], str):
                    original[key][kkey] = [original[key][kkey], new[key][kkey]]
                elif isinstance(original[key][kkey], list) and isinstance(new[key][kkey], str):
                    original[key][kkey].append(new[key][kkey])
                elif isinstance(original[key][kkey], str) and isinstance(new[key][kkey], list):
                    original[key][kkey] = new[key][kkey].append(original[key][kkey])
                elif isinstance(original[key][kkey], list) and isinstance(new[key][kkey], list):
                    original[key][kkey].extend(new[key][kkey])


def init_read_yaml_for_model():
    yaml_file_path = './config/adver_white_box.yaml'

    with open(yaml_file_path, 'r') as yaml_file:
        data_dict = yaml.safe_load(yaml_file)

    # print(data_dict)

    new_data_dict = os.listdir("./config")
    for item in new_data_dict:
        if item != 'adver_white_box.yaml':
            # print(item)
            with open(os.path.join("./config", item)) as yaml_file:
                new_data = yaml.safe_load(yaml_file)
                update_dict_1_level(data_dict, new_data)

    # print(data_dict)
    data_dict = replace_param(data_dict)
    return data_dict


def init_read_yaml_for_model_duplicate():
    yaml_file_path = './config/adver_white_box.yaml'

    with open(yaml_file_path, 'r') as yaml_file:
        data_dict = yaml.safe_load(yaml_file)

    # print(data_dict)

    new_data_dict = os.listdir("./config")
    for item in new_data_dict:
        if item != 'adver_white_box.yaml':
            with open(os.path.join("./config", item)) as yaml_file:
                new_data = yaml.safe_load(yaml_file)
                update_dict_2_level(data_dict, new_data)

    # print(data_dict)
    data_dict = replace_param(data_dict)
    return data_dict


def update_yaml():
    ## do we need this funcion?  To be added
    return 0


def translate_test_method(method):
    translations = {
        "FGSM": "快速梯度符号法",
        "PGD": "投影梯度下降",
        "CW": "CW攻击",
        "CW2": "CW2攻击",
        "DeepFool": "深度愚弄法",
        "fuzzing": "模糊测试"
    }
    return translations.get(method, method)


def get_container_id(container_name, client=None):
    if client is None:
        client = docker.from_env()
    name_id = {}
    # 列出所有运行中的容器
    containers = client.containers.list(all=True)
    for container in containers:
        # print(container.id, container.image, container.status, container.name)
        name_id[container.name] = container.id
    # print(name_id)
    if container_name in name_id:
        return name_id[container_name]
    raise BaseException(f"Not found container whit name {container_name}")


def exec_docker_container_shell_detach(shell_path: str) -> str:
    client = docker.from_env()

    parts = shell_path.split(":")
    container_name = parts[0]

    container_id = get_container_id(container_name, client)

    print(f"container_name: {container_name}, container_id: {container_id}")

    script_path = parts[1]
    cmd = f"bash -c '{script_path} &'"

    os.system("docker start %s" % (container_id))

    container = client.containers.get(container_id)

    print(f"script_path: {cmd}")

    exec_result = container.exec_run(cmd=cmd, detach=True)

    if exec_result.exit_code == 0:
        # 将输出从bytes解码为字符串
        try:
            # 尝试解码输出为 UTF-8 字符串，忽略解码错误，若仍出现解码错误请直接返回原始字节数据
            if isinstance(exec_result.output, str):
                print(exec_result.output)
                return exec_result.output
            output = exec_result.output.decode('utf-8', errors='ignore')
            print("Script output:", output)
            return output
        except UnicodeDecodeError:
            # 如果解码失败，返回原始字节数据
            print("Received non-UTF-8 output")
            return exec_result.output
    else:
        print("Script execution failed with exit code:", exec_result.exit_code)
        print("Error output:", exec_result.output)
        error_message = f"Script execution failed with exit code: {exec_result.exit_code}\nError output: {exec_result.output}"
        return error_message


def container_run_cmd(res: list, cmd, ctn):
    exec_result = ctn.exec_run(cmd=cmd)
    if exec_result.exit_code == 0:
        # 将输出从bytes解码为字符串
        try:
            if isinstance(exec_result.output, str):
                print(exec_result.output)
                return exec_result.output
            # 尝试解码输出为 UTF-8 字符串，忽略解码错误
            output = exec_result.output.decode('utf-8', errors='ignore')
            print("Script output:", output)
            res.append(output)
            return output
        except UnicodeDecodeError:
            # 如果解码失败，返回原始字节数据
            print("Received non-UTF-8 output")
            res.append(exec_result.output)
            return exec_result.output
    else:
        print("Script execution failed with exit code:", exec_result.exit_code)
        print("Error output:", exec_result.output.decode('utf-8'))
        error_message = f"Script execution failed with exit code: {exec_result.exit_code}\nError output: {exec_result.output.decode('utf-8')}"
        res.append(error_message)
        return error_message


def exec_docker_container_shell_detach_v2(shell_path: str) -> str:
    client = docker.from_env()

    parts = shell_path.split(":")

    container_name = parts[0]

    container_id = get_container_id(container_name, client)

    script_path = parts[1]

    # 启动docker
    os.system(f"docker start {container_id}")

    print(f"docker:{container_id} run cmd: {script_path}")

    container = client.containers.get(container_id)

    wait_time = 5  # 等待5秒
    result = []
    threading.Thread(target=container_run_cmd, args=(result, script_path, container)).start()

    time0 = time.time()

    while time.time() - time0 < wait_time:
        if len(result) > 0:
            return result[0]
        time.sleep(0.2)
    return "process is  running"


def exec_docker_container_shell(shell_path: str) -> str:
    client = docker.from_env()

    parts = shell_path.split(":")

    container_name = parts[0]

    container_id = get_container_id(container_name, client)

    script_path = parts[1]

    os.system("docker start %s" % (container_id))

    container = client.containers.get(container_id)

    print(f"script_path: {script_path}")

    exec_result = container.exec_run(cmd=script_path)

    if exec_result.exit_code == 0:
        # 将输出从bytes解码为字符串
        try:
            if isinstance(exec_result.output, str):
                print(exec_result.output)
                return exec_result.output
            # 尝试解码输出为 UTF-8 字符串，忽略解码错误
            output = exec_result.output.decode('utf-8', errors='ignore')
            print("Script output:", output)
            return output
        except UnicodeDecodeError:
            # 如果解码失败，返回原始字节数据
            print("Received non-UTF-8 output")
            return exec_result.output
    else:
        print("Script execution failed with exit code:", exec_result.exit_code)
        print("Error output:", exec_result.output.decode('utf-8'))
        error_message = f"Script execution failed with exit code: {exec_result.exit_code}\nError output: {exec_result.output.decode('utf-8')}"
        return error_message


def download_zip_from_docker(download_addr: str) -> io.BytesIO:
    container_id, zip_path = download_addr.split(":")

    client = docker.from_env()
    container = client.containers.get(container_id)
    bits,stat = container.get_archive(zip_path)

    file_stream = io.BytesIO()
    for chunk in bits:
        file_stream.write(chunk)
    file_stream.seek(0)

    return file_stream


def multi_file_download_from_docker(file_paths: list) -> io.BytesIO:
    client = docker.from_env()
    container_id = file_paths[0].split(":")[0]
    container = client.containers.get(container_id)

    file_sream = io.BytesIO()

    with zipfile.ZipFile(file_sream, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for file_path in file_paths:
            file_path = file_path.split(":")[1]
            bits, stat = container.get_archive(file_path)
            file_name_with_ext = file_path.split("/")[-1]
            file_name, _ = os.path.splitext(file_name_with_ext)
            zipf.writestr(f"{file_name}.tar", b''.join(bits))
    
    file_sream.seek(0)

    return file_sream


def upload_files_to_docker(file_paths, container_id, target_path="/root/file"):

    try:
        subprocess.run(["docker", "exec", container_id, "mkdir", "-p", target_path], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Failed to create directory in container: {e}")
        return

    # 拷贝文件到容器
    for file_path in file_paths:
        if not os.path.isfile(file_path):
            print(f"File {file_path} does not exist or is not a file. Skipping...")
            continue

        try:
            # 使用 docker cp 进行拷贝
            subprocess.run(
                ["docker", "cp", file_path, f"{container_id}:{target_path}"],
                check=True
            )
            print(f"Uploaded {file_path} to container {container_id}:{target_path}")
        except subprocess.CalledProcessError as e:
            print(f"Failed to copy {file_path} to container: {e}")


def replace_param(data_dict: dict, search_pool=None):
    """
    替换${}占位符参数
    :param data_dict:
    :return:
    """
    if search_pool is None:
        search_pool = data_dict
    ks = data_dict.keys()
    for k in ks:
        v = data_dict.get(k)
        if isinstance(v, str):
            while 0 <= v.find("${") < v.find("}"):
                start = v.find("${")
                end = v.find("}")
                rk = v[start+2:end]
                rv = search_pool
                for it in rk.split("."):
                    rv = rv.get(it)
                rk = "${" + rk + "}"
                nv = v.replace(rk, rv)
                data_dict[k] = nv
                v = data_dict.get(k)
        elif isinstance(v, dict):
            replace_param(v, search_pool)
    return data_dict


if __name__ == "__main__":
    data_dict = init_read_yaml_for_model()
    replace_param(data_dict)
    print(data_dict["ResNet"])
    print()

    # print(data_dict["Vgg16"]["docker_container"])
    # exec_docker_container_shell(data_dict["Vgg16"]["docker_container"])